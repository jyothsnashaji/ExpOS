alias fnum R1;
alias current_pid R2;
alias pgno R3;
alias bno R4;

if(fnum==1) then //disk store
 multipush(R0,R1,R2,R3,R4);
 R1=3;
 R2=[SYSTEM_STATUS_TABLE+1];
 call MOD_0;
 multipop(R0,R1,R2,R3,R4);

 
 [DISK_STATUS_TABLE+1]=1;
 [DISK_STATUS_TABLE+2]=pgno;
 [DISK_STATUS_TABLE+3]=bno;
 store (pgno,bno);
 [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+4]=WAIT_DISK;
 multipush(R0,R1,R2,R3,R4);
 call MOD_5;
 multipop(R0,R1,R2,R3,R4);
 return;
endif;
 

if (fnum==2) then //disk load
 multipush(R0,R1,R2,R3,R4);
 fnum=3; //pid in R2
 call MOD_0;
 multipop(R0,R1,R2,R3,R4);

 [DISK_STATUS_TABLE+1]=0;
 [DISK_STATUS_TABLE+2]=pgno;
 [DISK_STATUS_TABLE+3]=bno;
 load (pgno,bno);
 [PROCESS_TABLE+current_pid*16+4]=WAIT_DISK;
 multipush(R0,R1,R2,R3,R4);
 call MOD_5;
 multipop(R0,R1,R2,R3,R4);

 return;
endif;

 

if (fnum==3) then
multipush(R1,R2,R3);
fnum=8; //pid already in R2

call MOD_0;
multipop(R1,R2,R3);

print R3;

multipush(R1,R2,R3);
fnum=9;//pid already in R2
call MOD_0;
alias retval R0;
multipop(R1,R2,R3);
return;
endif;

if (fnum==4) then
multipush(R1,R2,R3);
fnum=8;//pid already in R2

call MOD_0;
multipop(R1,R2,R3);
read;
[PROCESS_TABLE+current_pid*16+4]=WAIT_TERMINAL;
multipush(R1,R2,R3);

call MOD_5;
multipop(R1,R2,R3);
alias phyaddress R4;
phyaddress=[PTBR+2*R3/512]*512+R3%512;
[phyaddress]=[PROCESS_TABLE+current_pid*16+8];
return;
endif;

return;
